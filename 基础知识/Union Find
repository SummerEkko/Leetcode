https://blog.csdn.net/Yzy_fulture/article/details/113069796  
最简单的一类union find: 套入模板直接就能解决的，如LC990  
复杂一些的，需要根据题意像并查集模板中添加一些自定义操作，如LC399  

过程分五步：初始化，写find，写union，用union，用find。

对比着LC990和LC399一起讲，自己去看答案：  
S1: 初始化：  
初始化是写一个集合，可以是list可以是dict，作用是：find的时候就来这里find，如典型的判断x == root[x]   
如果像399不是很好初始化的话，初始化步骤就给个空的，然后在find的时候去先初始化当前node再进行find操作。 

S2：写find函数：  
        def find(x):
            if x != root[x]:
                root[x] = find(root[x])
            return root[x]
这个是最经典的，很多题直接这么写就够了。这个是查找操作，也就是找cur_node的父辈是谁，父辈还有父辈的话继续找  
原理是：如果这个初始化集合里没有cur_node，它的parent就是parent的parent，也就是去find它父辈（这个if部分就算是初始化的补充）；如果有了，就去寻找它的上一级是谁。  

而399就比较复杂一些，因为逻辑上不能简单用root[i]=i来构造了，root[i]要等于别的，所以就要用这种字典的方法构造。  
二者的区别是：990的初始list是有值的，所以find的时候如果x != root[x]，那他一定等于别的，直接往上一辈一辈find就完事了；而399的init_dict是空的，所以当node_id not in gid_weight时，说明它本身还没参与进来，这时要做的不是去往父辈找，而是给它赋初值。  
然后第二步是取值，这两部是比990多出来的，990直接find就完事，但是399就是因为init_dict为空所以要先确保没参与的话先赋值，然后再取值。至此，取到值了，剩下就跟990一样了。  
第三步，!=，往父辈找  
第四步，return父辈  

S3: 写union函数：  
        def union(x, y):
            x, y = find(x), find(y)
            root[x] = y
这个也是最基本的模板，做的是合并操作，俗称认祖宗。也就是把当前的祖宗当做别人的儿子合并过去，认祖归宗，并在一起了。  
399与990不同的在于，和find一样，就是因为一个初始集合全部位置都有值，可以直接操作；而399的初始集合是空的，所以要多一步确认，再操作。  
399的判断逻辑是：当除数和被除数不一样时再去认祖宗。因为一样的话就是自己，并不需要传递了。  

S4：根据题意去用union：  
990中，俩字母是等号，就连通了，所以union。  
399中，遍历一遍所有的都union，399比990少了判断是因为399的union函数里带的判断。  

S5：根据题意去用find：  
990中，遇到哪个！=了，他就有潜在的可能造成冲突，从而导致FALSE，所以遇到！就check一下，check的内容就是find两边的元素。if find(x) == find(y):的意思就是检查这二者是不是有共同祖先，也就是是否连通。根据题意，是不该连通的。若不该连通的连通了，那就return FALSE。  
399中，首先若有查询元素并不存在在图里，就append个-1；其次，去分别find然后检查连通性，根据题意，连不通的就添加-1了；若能连通，这里就是彻底体现DIY的地方了：results.append(dividend_weight / divisor_weight)。这个_weight都是这两个node针对最孙子的那个node的倍数，所以把最孙子的作为单位1，两个weight相除就OK。  

END
