# Reference: https://labuladong.github.io/algo/  

1. 操作不在递归遍历内，而是在之外。
之前一直有个困惑：根据题意自定义部分的code到底写在哪呢？感觉递归函数没什么操作的地方，写到别处又插入不到递归内。答案是：

(1). 由于是递归，所以一定要在return的这个值上做文章。在return的内容上就文章，就可以把自定义部分的操作插入到整个遍历得到的结果里了
eg: lc104

(2). 经典DFS的内容，想操作每一步递归，就在递归函数内操作参数，如：
// 二叉树遍历函数
void traverse(TreeNode root, int level) {
    if (root == null) {
        return;
    }
    // 前序位置
    printf("节点 %s 在第 %d 层", root, level);
    traverse(root.left, level + 1);
    traverse(root.right, level + 1);
}

// 这样调用
traverse(root, 1);

2. 一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。    

eg1: 如何打印出每个节点的左右子树各有多少节点？  
// 定义：输入一棵二叉树，返回这棵二叉树的节点总数
int count(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftCount = count(root.left);
    int rightCount = count(root.right);
    // 后序位置
    printf("节点 %s 的左子树有 %d 个节点，右子树有 %d 个节点",
            root, leftCount, rightCount);

    return leftCount + rightCount + 1;
}  

eg2: lc543  
  
3. 开头记得写个 if not root: return []类似的
